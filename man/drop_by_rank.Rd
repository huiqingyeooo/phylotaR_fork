% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/user-drop.R
\name{drop_by_rank}
\alias{drop_by_rank}
\title{Reduce clusters to specific rank}
\usage{
drop_by_rank(
  phylota,
  rnk = "species",
  keep_higher = FALSE,
  n = 10,
  choose_by = c("pambgs", "age", "nncltds"),
  greatest = c(FALSE, FALSE, TRUE)
)
}
\arguments{
\item{phylota}{Phylota object}

\item{rnk}{Taxonomic rank}

\item{keep_higher}{Keep higher taxonomic ranks?}

\item{n}{Number of sequences per taxon}

\item{choose_by}{Vector of selection functions}

\item{greatest}{Greatest of lowest for each choose_by function}
}
\value{
phylota
}
\description{
Identifies higher level taxa for each sequence in clusters for
given rank. Selects representative sequences for each unique taxon using the
choose_by functions. By default, the function will choose the top ten
sequences by first sorting by those with fewest number of ambiguous
sequences, then by youngest, then by sequence length.
}
\examples{
data("dragonflies")
# For faster computations, let's only work with the 5 clusters.
dragonflies <- drop_clstrs(phylota = dragonflies, cid = dragonflies@cids[10:15])


# We can use drop_by_rank() to reduce to 10 sequences per genus for each cluster
(reduced_1 <- drop_by_rank(phylota = dragonflies, rnk = 'genus', n = 10,
                           choose_by = c('pambgs', 'age', 'nncltds'),
                           greatest = c(FALSE, FALSE, TRUE)))

# We can specify what aspects of the sequences we would like to select per genus
# By default we select the sequences with fewest ambiguous nucleotides (e.g.
# we avoid Ns), the youngest age and then longest sequence.
# We can reverse the 'greatest' to get the opposite.
(reduced_2 <- drop_by_rank(phylota = dragonflies, rnk = 'genus', n = 10,
                           choose_by = c('pambgs', 'age', 'nncltds'),
                           greatest = c(TRUE, TRUE, FALSE)))


# Leading to smaller sequnces ...
r1_sqlngth <- mean(get_sq_slot(phylota = reduced_1,
                                sid = reduced_1@sids, slt_nm = 'nncltds'))
r2_sqlngth <- mean(get_sq_slot(phylota = reduced_2,
                                sid = reduced_2@sids, slt_nm = 'nncltds'))
(r1_sqlngth > r2_sqlngth)
# ... with more ambigous characters ....
r1_pambgs <- mean(get_sq_slot(phylota = reduced_1, sid = reduced_1@sids,
                              slt_nm = 'pambgs'))
r2_pambgs <- mean(get_sq_slot(phylota = reduced_2, sid = reduced_2@sids,
                              slt_nm = 'pambgs'))
(r1_pambgs < r2_pambgs)
# .... and older ages (measured in days since being added to GenBank).
r1_age <- mean(get_sq_slot(phylota = reduced_1, sid = reduced_1@sids,
                           slt_nm = 'age'))
r2_age <- mean(get_sq_slot(phylota = reduced_2, sid = reduced_2@sids,
                           slt_nm = 'age'))
(r1_age < r2_age)


# Or... we can simply reduce the clusters to just one sequence per genus
(dragonflies <- drop_by_rank(phylota = dragonflies, rnk = 'genus', n = 1))
}
\seealso{
Other tools-public: 
\code{\link{calc_mad}()},
\code{\link{calc_wrdfrq}()},
\code{\link{drop_clstrs}()},
\code{\link{drop_sqs}()},
\code{\link{get_clstr_slot}()},
\code{\link{get_nsqs}()},
\code{\link{get_ntaxa}()},
\code{\link{get_sq_slot}()},
\code{\link{get_stage_times}()},
\code{\link{get_tx_slot}()},
\code{\link{get_txids}()},
\code{\link{is_txid_in_clstr}()},
\code{\link{is_txid_in_sq}()},
\code{\link{list_clstrrec_slots}()},
\code{\link{list_ncbi_ranks}()},
\code{\link{list_seqrec_slots}()},
\code{\link{list_taxrec_slots}()},
\code{\link{plot_phylota_pa}()},
\code{\link{plot_phylota_treemap}()},
\code{\link{read_phylota}()},
\code{\link{write_sqs}()}
}
\concept{tools-public}
